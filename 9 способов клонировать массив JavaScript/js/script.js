
let a = [1, 3, 5, [6, 7]]; // есть массив со вложенным массивом

//let b = [...a]; // используем оператор СПРЭД(...) чтобы клонировать массивы, но при вложенности массивов это не работает именно со вложенными массивами, с обычном работает


// здесь мы используем цикл для клонирования массива, но при вложенности массивов это так же не работает именно со вложенными массивами, с обычном работает
// let b = [];
// for (let i = 0; i < a.length; i++) {
// b[i] = a[i];
// }


// используем метод MAP(), но при вложенности массивов это так же не работает именно со вложенными массивами, с обычном работает
// let b = a.map(x => x);

// используем метод filter(), но при вложенности массивов это так же не работает именно со вложенными массивами, с обычном работает
// let b = a.filter(() => true);



// используем метод slice(), но при вложенности массивов это так же не работает именно со вложенными массивами, с обычном работает
// let b = a.slice();



// используем метод concat(), но при вложенности массивов это так же не работает именно со вложенными массивами, с обычном работает
// let b = a.concat([]);



// используем метод Array.from(), но при вложенности массивов это так же не работает именно со вложенными массивами, с обычном работает
// let b = Array.from(a);


// !!!!!! а вот здесь мы превратили вложенный массив(a[]) в строку и потом распарсили его и у нас получилось клонировать этот вложенный массив на два обсолютно независимых массива и при запушивании в массив (a[]) чего бы то нибыло массив(b[]) остаётся изначальным (но есть два важных нюанса: 1-этот способ очень сильно нагружает движок, и он очень тяжёлый если много массивов и вложенности; 2-этот метод ломает объекты если они присутствуют в массиве поэтому очень аккурвтно его применять!)
let b = JSON.parse(JSON.stringify(a));


a.push('test');
a[3].push(999);

console.log('array a');
console.log(a);

console.log('array b');
console.log(b);







